import { Test, TestingModule } from '@nestjs/testing';
import { BandsService } from './bands.service';
import { BandsRepository } from './bands.repository';
import { ConflictException, NotFoundException } from '@nestjs/common';
import { getRepositoryToken } from '@nestjs/typeorm';\nimport { Band } from './entities/band.entity';
import { Country } from '../countries/entities/country.entity';
import { DataSource } from 'typeorm';

describe('BandsService - Optimistic Locking', () => {
  let bandsService: BandsService;
  let bandsRepository: BandsRepository;
  let dataSource: DataSource;

  const mockBand = {\n    id: 1,\n    name: 'The Beatles',\n    genre: 'Rock',\n    yearFormed: 1960,\n    version: 1,\n    active: true,\n    website: 'https://www.thebeatles.com',\n    description: 'English rock band',\n    imageUrl: null,\n    country: { id: 1, name: 'United Kingdom' },\n    members: [],\n    albums: [],\n    songs: [],\n    events: [],\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    deletedAt: null,\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        BandsService,\n        {\n          provide: BandsRepository,\n          useValue: {\n            findOne: jest.fn(),\n            update: jest.fn(),\n            findOneWithRelations: jest.fn(),\n            softDelete: jest.fn(),\n            create: jest.fn(),\n            save: jest.fn(),\n            findByNamePattern: jest.fn(),\n            findByFirstLetter: jest.fn(),\n            findByGenre: jest.fn(),\n            findByYear: jest.fn(),\n            findByCountry: jest.fn(),\n            findAllWithRelations: jest.fn(),\n          },\n        },\n        {\n          provide: getRepositoryToken(Country),\n          useValue: {\n            findOne: jest.fn(),\n          },\n        },\n        {\n          provide: DataSource,\n          useValue: {\n            createQueryRunner: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    bandsService = module.get<BandsService>(BandsService);\n    bandsRepository = module.get<BandsRepository>(BandsRepository);\n    dataSource = module.get<DataSource>(DataSource);\n  });\n\n  describe('update with optimistic locking', () => {\n    it('should throw ConflictException when version has been modified', async () => {\n      const bandId = 1;\n      const updateDto = { name: 'The Rolling Stones' };\n\n      // Mock initial fetch returns the band\n      (bandsRepository.findOne as jest.Mock).mockResolvedValueOnce(mockBand);\n\n      // Mock update returning affected = 0 (version mismatch)\n      (bandsRepository.update as jest.Mock).mockResolvedValueOnce({\n        affected: 0,\n      });\n\n      await expect(\n        bandsService.update(bandId, updateDto),\n      ).rejects.toThrow(ConflictException);\n\n      // Should have included version in where clause\n      expect(bandsRepository.update).toHaveBeenCalledWith(\n        { id: bandId, version: mockBand.version },\n        updateDto,\n      );\n    });\n\n    it('should successfully update when version matches', async () => {\n      const bandId = 1;\n      const updateDto = { name: 'The Rolling Stones' };\n      const updatedBand = { ...mockBand, name: 'The Rolling Stones', version: 2 };\n\n      // Mock initial fetch\n      (bandsRepository.findOne as jest.Mock).mockResolvedValueOnce(mockBand);\n\n      // Mock successful update (affected = 1)\n      (bandsRepository.update as jest.Mock).mockResolvedValueOnce({\n        affected: 1,\n      });\n\n      // Mock the fetch of updated band\n      (bandsRepository.findOneWithRelations as jest.Mock).mockResolvedValueOnce(\n        updatedBand,\n      );\n\n      const result = await bandsService.update(bandId, updateDto);\n\n      expect(result).toEqual(updatedBand);\n      // Should have used version in where clause\n      expect(bandsRepository.update).toHaveBeenCalledWith(\n        { id: bandId, version: mockBand.version },\n        updateDto,\n      );\n    });\n\n    it('should throw NotFoundException when band does not exist', async () => {\n      const bandId = 999;\n      const updateDto = { name: 'Unknown Band' };\n\n      // Mock findOne returns null\n      (bandsRepository.findOne as jest.Mock).mockResolvedValueOnce(null);\n\n      await expect(\n        bandsService.update(bandId, updateDto),\n      ).rejects.toThrow(NotFoundException);\n\n      // Should not attempt update\n      expect(bandsRepository.update).not.toHaveBeenCalled();\n    });\n\n    it('should handle database unique constraint violations', async () => {\n      const bandId = 1;\n      const updateDto = { name: 'Existing Band' };\n\n      // Mock initial fetch\n      (bandsRepository.findOne as jest.Mock).mockResolvedValueOnce(mockBand);\n\n      // Mock database unique constraint violation\n      const dbError = new Error('duplicate key value violates unique constraint');\n      (dbError as any).code = '23505';\n      (bandsRepository.update as jest.Mock).mockRejectedValueOnce(dbError);\n\n      await expect(\n        bandsService.update(bandId, updateDto),\n      ).rejects.toThrow(ConflictException);\n    });\n  });\n\n  describe('optimistic locking prevents lost updates', () => {\n    it('scenario: concurrent updates to different fields', async () => {\n      const bandId = 1;\n\n      // Simulate two concurrent requests\n      const updateDto1 = { name: 'New Name' };\n      const updateDto2 = { genre: 'Heavy Metal' };\n\n      // Both start with the same version\n      (bandsRepository.findOne as jest.Mock)\n        .mockResolvedValueOnce(mockBand)\n        .mockResolvedValueOnce(mockBand);\n\n      // First request succeeds\n      (bandsRepository.update as jest.Mock).mockResolvedValueOnce({\n        affected: 1,\n      });\n\n      // Second request fails (version is now 2)\n      (bandsRepository.update as jest.Mock).mockResolvedValueOnce({\n        affected: 0,\n      });\n\n      // First update\n      await bandsService.update(bandId, updateDto1);\n\n      // Second update should fail and client should retry\n      await expect(\n        bandsService.update(bandId, updateDto2),\n      ).rejects.toThrow(ConflictException);\n\n      // Both should have used version in where clause\n      expect(bandsRepository.update).toHaveBeenNthCalledWith(\n        1,\n        { id: bandId, version: 1 },\n        updateDto1,\n      );\n      expect(bandsRepository.update).toHaveBeenNthCalledWith(\n        2,\n        { id: bandId, version: 1 },\n        updateDto2,\n      );\n    });\n  });\n});\n